\section{Methods}
\label{sec:methods}

\subsection{Encodings}
\label{sec:methods:encode}

Two encodings of the SLOW5 file format were designed and implemented. The first is a binary encoding where each numerical field is stored in binary rather than in the ASCII\nomenclature{ASCII}{American Standard Code for Information Interchange: An encoding for representing text on computers} format. This is analogous to how SAM \cite{sam:file, sam:stats} and VCF \cite{vcf:file}, two gold standard genomics file formats, have their own binary counterparts BAM and BCF. This encoding is more natural for almost all modern computers since digital memory is designed to store data in binary. It is also significantly more efficient in theory, with one byte of data capable of storing the 10 digits in ASCII versus $256$ ($ = 2^8$) numbers in binary.

The binary encoding also removes the commas, tab characters and the newline characters separating signal data, fields and reads respectively since the size of each numerical field is now static. For all remaining variable length fields such as the read identifier (ID\nomenclature{ID}{Identifier}), the encoding prepends them by a static sized numerical field storing their length in bytes. This prepended field is also stored in binary. An example is displayed in figure \ref{tab:blow5}.

The second encoding is a compressed binary encoding in the gzip file format \cite{gzip}. This is achieved by separately compressing the header and each read of the binary encoded SLOW5 file format using the default level of compression, internal memory allocation and compression algorithm of the zlib C library \cite{zlib}. An example is shown in figure \ref{tab:blow5gz}.

\subsection{Multithreading}
\label{sec:methods:multi}

Reading \textit{reads} from the SLOW5 file format can be performed by multiple threads in parallel as was mentioned in section \ref{sec:intro}. The method is the same for all encodings (ASCII, binary and compressed binary) and works as follows.

The algorithm takes as input a SLOW5 file and a list of read IDs. It then outputs the list of reads from the SLOW5 file corresponding to the given read IDs. First of all, it generates a SLOW5 index file (section \ref{sec:intro}) for the SLOW5 file of interest, if it does not exist already. This index file is then stored in memory as a hash table where the key is the read ID and the values are the location and size in bytes of each read. Then, the list of read IDs are processed one batch at a time to avoid an out of memory state, with the maximum number of read IDs in a batch set arbitrarily to $2^{12}$. Each thread is then allocated an equal amount of read IDs from the current batch. The threads then begin iterating in parallel through their allocated read IDs.

For each read ID, the offset and length of the corresponding read are found from the hash table. The offset is then used to locate the beginning of the read in the SLOW5 file and the length dictates how many bytes to read from that position into memory for later output.

Work stealing between threads occurs in the case that a thread completes the above task for all their allocated reads earlier than another. Once all read IDs in the current batch have been processed, the stored reads are written as output and freed from the program's memory. The next batch then begins if there are remaining read IDs to process from the initial list.

This algorithm displays the superiority of the simple SLOW5 file format over FAST5 since it very basically overcomes the thread scalability issue outlined in section \ref{sec:back}. In fact, it implements parallel access without any synchronisation mechanisms and is inherently thread-safe since the SLOW5 file is read-only throughout the entire algorithm and each stored read is written to a pre-allocated position in memory.
